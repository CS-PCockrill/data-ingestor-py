import logging
import datetime

import cx_Oracle
import psycopg2


class SQLLogger:
    """
    A custom SQL logger that logs messages to an Oracle or PostgreSQL database.
    """

    def __init__(self, db_config):
        """
        Initialize the logger and set up the database connection and table.

        Args:
            db_config (dict): Database configuration with keys:
                              - "type" ("oracle" or "postgresql")
                              - "host"
                              - "port"
                              - "database"
                              - "user"
                              - "password"
        """
        self.db_config = db_config
        self.db_type = db_config.get("type").lower()
        self.conn = None
        self.cursor = None

        if self.db_type not in ["oracle", "postgresql"]:
            raise ValueError("Unsupported database type. Use 'oracle' or 'postgresql'.")

        self._connect()
        self._setup_table()
        logging.info(f"SQL Logger initialized with {self.db_type} database.")

    def _connect(self):
        """Establish a database connection based on the type."""
        try:
            if self.db_type == "oracle":
                self.conn = cx_Oracle.connect(
                    user=self.db_config["user"],
                    password=self.db_config["password"],
                    dsn=f"{self.db_config['host']}:{self.db_config['port']}/{self.db_config['database']}",
                )
            elif self.db_type == "postgresql":
                self.conn = psycopg2.connect(
                    host=self.db_config["host"],
                    port=self.db_config["port"],
                    database=self.db_config["database"],
                    user=self.db_config["user"],
                    password=self.db_config["password"],
                )
            self.cursor = self.conn.cursor()
        except Exception as e:
            logging.error(f"Failed to connect to {self.db_type} database: {e}")
            raise

    def _setup_table(self):
        """Create the logs table if it doesn't already exist."""
        create_table_query = """
        CREATE TABLE IF NOT EXISTS logs (
            id SERIAL PRIMARY KEY,
            timestamp TIMESTAMP NOT NULL,
            log_level VARCHAR(50) NOT NULL,
            message TEXT NOT NULL,
            metadata TEXT,
            status VARCHAR(50),
            start_time TIMESTAMP,
            end_time TIMESTAMP
        )
        """
        if self.db_type == "oracle":
            create_table_query = """
            BEGIN
                EXECUTE IMMEDIATE 'CREATE TABLE logs (
                    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                    timestamp TIMESTAMP NOT NULL,
                    log_level VARCHAR2(50) NOT NULL,
                    message CLOB NOT NULL,
                    metadata CLOB,
                    status VARCHAR2(50),
                    start_time TIMESTAMP,
                    end_time TIMESTAMP
                )';
            EXCEPTION
                WHEN OTHERS THEN
                    IF SQLCODE != -955 THEN RAISE; END IF;
            END;
            """
        try:
            self.cursor.execute(create_table_query)
            self.conn.commit()
            logging.info(f"Logs table verified or created for {self.db_type}.")
        except Exception as e:
            logging.error(f"Failed to create logs table: {e}")
            raise

    def _log(self, log_level, message, metadata=None, status=None, start_time=None, end_time=None):
        """
        Internal method to insert a log into the database.

        Args:
            log_level (str): Level of the log (e.g., INFO, WARN, ERROR).
            message (str): The log message.
            metadata (str): Additional metadata (optional).
            status (str): Success or failure status (optional).
            start_time (str): Start time of the process (optional).
            end_time (str): End time of the process (optional).
        """
        timestamp = datetime.utcnow()
        insert_query = """
        INSERT INTO logs (timestamp, log_level, message, metadata, status, start_time, end_time)
        VALUES (%s, %s, %s, %s, %s, %s, %s)
        """
        if self.db_type == "oracle":
            insert_query = """
            INSERT INTO logs (id, timestamp, log_level, message, metadata, status, start_time, end_time)
            VALUES (logs_seq.NEXTVAL, :1, :2, :3, :4, :5, :6, :7)
            """
        try:
            params = (timestamp, log_level, message, metadata, status, start_time, end_time)
            if self.db_type == "oracle":
                params = (timestamp, log_level, message, metadata, status, start_time, end_time)
            self.cursor.execute(insert_query, params)
            self.conn.commit()
            logging.debug(f"Log inserted into {self.db_type}: {log_level} - {message}")
        except Exception as e:
            logging.error(f"Failed to insert log: {e}")
            raise

    def info(self, message, metadata=None):
        """Log an informational message."""
        self._log("INFO", message, metadata)

    def warn(self, message, metadata=None):
        """Log a warning message."""
        self._log("WARN", message, metadata)

    def error(self, message, metadata=None):
        """Log an error message."""
        self._log("ERROR", message, metadata)

    def start_process(self, message, metadata=None):
        """
        Log the start of a process.

        Args:
            message (str): Process start message.
            metadata (str): Additional metadata (optional).
        Returns:
            str: The start timestamp.
        """
        start_time = str(datetime.datetime.now(datetime.timezone.utc))
        self._log("PROCESS_START", message, metadata, status="STARTED", start_time=start_time)
        return start_time

    def end_process(self, message, start_time, metadata=None, success=True):
        """
        Log the end of a process.

        Args:
            message (str): Process end message.
            start_time (str): The start timestamp of the process.
            metadata (str): Additional metadata (optional).
            success (bool): Whether the process was successful.
        """
        end_time = str(datetime.datetime.now(datetime.timezone.utc))
        status = "SUCCESS" if success else "FAILURE"
        self._log("PROCESS_END", message, metadata, status=status, start_time=start_time, end_time=end_time)

    def close(self):
        """Close the database connection."""
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
        logging.info(f"SQL Logger connection to {self.db_type} closed.")
